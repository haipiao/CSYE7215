


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Distributed Data &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4.20',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <script type="text/javascript" src="../_static/warnOldDocs.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Networking" href="index-network.html" />
    <link rel="next" title="Remoting" href="remoting.html" />
    <link rel="prev" title="Cluster Metrics Extension" href="cluster-metrics.html" />


  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>
          <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Distributed Data - Version 2.4.20</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <div class="breadcrumb">
              <div style="position: relative">
                <input type="search" id="search" class="form-control" style="position: relative" placeholder="Search in the doc" />
              </div>
              <div>
                <div>
                  <span class="divider">«</span> <a href="cluster-metrics.html">Cluster Metrics Extension</a> <span class="divider">|</span>
                </div>
                <div>
                  <a href="../java.html">Java Contents</a> <span class="divider">|</span> <a href="../scala.html">Scala Contents</a>
                </div>
                <div>
                  <span class="divider">|</span> <a href="remoting.html">Remoting</a> <span class="divider">»</span>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="distributed-data">
<span id="distributed-data-scala"></span><h1>Distributed Data</h1>
<p><em>Akka Distributed Data</em> is useful when you need to share data between nodes in an
Akka Cluster. The data is accessed with an actor providing a key-value store like API.
The keys are unique identifiers with type information of the data values. The values
are <em>Conflict Free Replicated Data Types</em> (CRDTs).</p>
<p>All data entries are spread to all nodes, or nodes with a certain role, in the cluster
via direct replication and gossip based dissemination. You have fine grained control
of the consistency level for reads and writes.</p>
<p>The nature CRDTs makes it possible to perform updates from any node without coordination.
Concurrent updates from different nodes will automatically be resolved by the monotonic
merge function, which all data types must provide. The state changes always converge.
Several useful data types for counters, sets, maps and registers are provided and
you can also implement your own custom data types.</p>
<p>It is eventually consistent and geared toward providing high read and write availability
(partition tolerance), with low latency. Note that in an eventually consistent system a read may return an
out-of-date value.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This module is marked as <strong>“experimental”</strong> as of its introduction in Akka 2.4.0. We will continue to
improve this API based on our users’ feedback, which implies that while we try to keep incompatible
changes to a minimum the binary compatibility guarantee for maintenance releases does not apply to the
contents of the <tt class="docutils literal"><span class="pre">akka.persistence</span></tt> package.</p>
</div>
<div class="section" id="using-the-replicator">
<h2>Using the Replicator</h2>
<p>The <tt class="docutils literal"><span class="pre">akka.cluster.ddata.Replicator</span></tt> actor provides the API for interacting with the data.
The <tt class="docutils literal"><span class="pre">Replicator</span></tt> actor must be started on each node in the cluster, or group of nodes tagged
with a specific role. It communicates with other <tt class="docutils literal"><span class="pre">Replicator</span></tt> instances with the same path
(without address) that are running on other nodes . For convenience it can be used with the
<tt class="docutils literal"><span class="pre">akka.cluster.ddata.DistributedData</span></tt> extension.</p>
<p>Cluster members with status <a class="reference internal" href="cluster-usage.html#weakly-up-scala"><em>WeaklyUp</em></a>, if that feature is enabled,
will participate in Distributed Data. This means that the data will be replicated to the
<a class="reference internal" href="cluster-usage.html#weakly-up-scala"><em>WeaklyUp</em></a> nodes with the background gossip protocol. Note that it
will not participate in any actions where the consistency mode is to read/write from all
nodes or the majority of nodes. The <a class="reference internal" href="cluster-usage.html#weakly-up-scala"><em>WeaklyUp</em></a> node is not counted
as part of the cluster. So 3 nodes + 5 <a class="reference internal" href="cluster-usage.html#weakly-up-scala"><em>WeaklyUp</em></a> is essentially a
3 node cluster as far as consistent actions are concerned.</p>
<p>Below is an example of an actor that schedules tick messages to itself and for each tick
adds or removes elements from a <tt class="docutils literal"><span class="pre">ORSet</span></tt> (observed-remove set). It also subscribes to
changes of this.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">java.util.concurrent.ThreadLocalRandom</span>
<span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorLogging</span>
<span class="k">import</span> <span class="nn">akka.cluster.Cluster</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.DistributedData</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.ORSet</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.ORSetKey</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.Replicator</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.Replicator._</span>

<span class="k">object</span> <span class="nc">DataBot</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Tick</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">DataBot</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ActorLogging</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">DataBot._</span>

  <span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">)</span>

  <span class="k">import</span> <span class="nn">context.dispatcher</span>
  <span class="k">val</span> <span class="n">tickTask</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">schedule</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">,</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">,</span> <span class="n">self</span><span class="o">,</span> <span class="nc">Tick</span><span class="o">)</span>

  <span class="k">val</span> <span class="nc">DataKey</span> <span class="k">=</span> <span class="nc">ORSetKey</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;key&quot;</span><span class="o">)</span>

  <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Subscribe</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="n">self</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Tick</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="nc">ThreadLocalRandom</span><span class="o">.</span><span class="n">current</span><span class="o">().</span><span class="n">nextInt</span><span class="o">(</span><span class="mi">97</span><span class="o">,</span> <span class="mi">123</span><span class="o">).</span><span class="n">toChar</span><span class="o">.</span><span class="n">toString</span>
      <span class="k">if</span> <span class="o">(</span><span class="nc">ThreadLocalRandom</span><span class="o">.</span><span class="n">current</span><span class="o">().</span><span class="n">nextBoolean</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// add</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Adding: {}&quot;</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
        <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">ORSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="nc">WriteLocal</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="n">s</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// remove</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Removing: {}&quot;</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
        <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">ORSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="nc">WriteLocal</span><span class="o">)(</span><span class="k">_</span> <span class="o">-</span> <span class="n">s</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="k">_:</span> <span class="kt">UpdateResponse</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="c1">// ignore</span>

    <span class="k">case</span> <span class="n">c</span> <span class="k">@</span> <span class="nc">Changed</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">)</span>
      <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Current elements: {}&quot;</span><span class="o">,</span> <span class="n">data</span><span class="o">.</span><span class="n">elements</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">postStop</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">tickTask</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>

<span class="o">}</span>
</pre></div>
</div>
<div class="section" id="update">
<span id="replicator-update-scala"></span><h3>Update</h3>
<p>To modify and replicate a data value you send a <tt class="docutils literal"><span class="pre">Replicator.Update</span></tt> message to the local
<tt class="docutils literal"><span class="pre">Replicator</span></tt>.</p>
<p>The current data value for the <tt class="docutils literal"><span class="pre">key</span></tt> of the <tt class="docutils literal"><span class="pre">Update</span></tt> is passed as parameter to the <tt class="docutils literal"><span class="pre">modify</span></tt>
function of the <tt class="docutils literal"><span class="pre">Update</span></tt>. The function is supposed to return the new value of the data, which
will then be replicated according to the given consistency level.</p>
<p>The <tt class="docutils literal"><span class="pre">modify</span></tt> function is called by the <tt class="docutils literal"><span class="pre">Replicator</span></tt> actor and must therefore be a pure
function that only uses the data parameter and stable fields from enclosing scope. It must
for example not access <tt class="docutils literal"><span class="pre">sender()</span></tt> reference of an enclosing actor.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Update</span></tt> is intended to only be sent from an actor running in same local <tt class="docutils literal"><span class="pre">ActorSystem</span></tt> as</dt>
<dd><ul class="first last simple">
<li>the <cite>Replicator</cite>, because the <cite>modify</cite> function is typically not serializable.</li>
</ul>
</dd>
</dl>
<p>You supply a write consistency level which has the following meaning:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">WriteLocal</span></tt> the value will immediately only be written to the local replica,
and later disseminated with gossip</li>
<li><tt class="docutils literal"><span class="pre">WriteTo(n)</span></tt> the value will immediately be written to at least <tt class="docutils literal"><span class="pre">n</span></tt> replicas,
including the local replica</li>
<li><tt class="docutils literal"><span class="pre">WriteMajority</span></tt> the value will immediately be written to a majority of replicas, i.e.
at least <strong>N/2 + 1</strong> replicas, where N is the number of nodes in the cluster
(or cluster role group)</li>
<li><tt class="docutils literal"><span class="pre">WriteAll</span></tt> the value will immediately be written to all nodes in the cluster
(or all nodes in the cluster role group)</li>
</ul>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>

<span class="k">val</span> <span class="nc">Counter1Key</span> <span class="k">=</span> <span class="nc">PNCounterKey</span><span class="o">(</span><span class="s">&quot;counter1&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Set1Key</span> <span class="k">=</span> <span class="nc">GSetKey</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;set1&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Set2Key</span> <span class="k">=</span> <span class="nc">ORSetKey</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;set2&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">ActiveFlagKey</span> <span class="k">=</span> <span class="nc">FlagKey</span><span class="o">(</span><span class="s">&quot;active&quot;</span><span class="o">)</span>

<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">PNCounter</span><span class="o">(),</span> <span class="nc">WriteLocal</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">val</span> <span class="n">writeTo3</span> <span class="k">=</span> <span class="nc">WriteTo</span><span class="o">(</span><span class="n">n</span> <span class="k">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">timeout</span> <span class="k">=</span> <span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">writeTo3</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="s">&quot;hello&quot;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">writeMajority</span> <span class="k">=</span> <span class="nc">WriteMajority</span><span class="o">(</span><span class="n">timeout</span> <span class="k">=</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">Set2Key</span><span class="o">,</span> <span class="nc">ORSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">writeMajority</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="s">&quot;hello&quot;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">writeAll</span> <span class="k">=</span> <span class="nc">WriteAll</span><span class="o">(</span><span class="n">timeout</span> <span class="k">=</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">ActiveFlagKey</span><span class="o">,</span> <span class="nc">Flag</span><span class="o">.</span><span class="n">empty</span><span class="o">,</span> <span class="n">writeAll</span><span class="o">)(</span><span class="k">_</span><span class="o">.</span><span class="n">switchOn</span><span class="o">)</span>
</pre></div>
</div>
<p>As reply of the <tt class="docutils literal"><span class="pre">Update</span></tt> a <tt class="docutils literal"><span class="pre">Replicator.UpdateSuccess</span></tt> is sent to the sender of the
<tt class="docutils literal"><span class="pre">Update</span></tt> if the value was successfully replicated according to the supplied consistency
level within the supplied timeout. Otherwise a <tt class="docutils literal"><span class="pre">Replicator.UpdateFailure</span></tt> subclass is
sent back. Note that a <tt class="docutils literal"><span class="pre">Replicator.UpdateTimeout</span></tt> reply does not mean that the update completely failed
or was rolled back. It may still have been replicated to some nodes, and will eventually
be replicated to all nodes with the gossip protocol.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="nc">UpdateSuccess</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// ok</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="nc">UpdateSuccess</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="c1">// ok</span>
<span class="k">case</span> <span class="nc">UpdateTimeout</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span>  <span class="k">=&gt;</span>
<span class="c1">// write to 3 nodes failed within 1.second</span>
</pre></div>
</div>
<p>You will always see your own writes. For example if you send two <tt class="docutils literal"><span class="pre">Update</span></tt> messages
changing the value of the same <tt class="docutils literal"><span class="pre">key</span></tt>, the <tt class="docutils literal"><span class="pre">modify</span></tt> function of the second message will
see the change that was performed by the first <tt class="docutils literal"><span class="pre">Update</span></tt> message.</p>
<p>In the <tt class="docutils literal"><span class="pre">Update</span></tt> message you can pass an optional request context, which the <tt class="docutils literal"><span class="pre">Replicator</span></tt>
does not care about, but is included in the reply messages. This is a convenient
way to pass contextual information (e.g. original sender) without having to use <tt class="docutils literal"><span class="pre">ask</span></tt>
or maintain local correlation data structures.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>
<span class="k">val</span> <span class="n">writeTwo</span> <span class="k">=</span> <span class="nc">WriteTo</span><span class="o">(</span><span class="n">n</span> <span class="k">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">timeout</span> <span class="k">=</span> <span class="mf">3.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Counter1Key</span> <span class="k">=</span> <span class="nc">PNCounterKey</span><span class="o">(</span><span class="s">&quot;counter1&quot;</span><span class="o">)</span>

<span class="k">def</span> <span class="n">receive</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">&quot;increment&quot;</span> <span class="k">=&gt;</span>
    <span class="c1">// incoming command to increase the counter</span>
    <span class="k">val</span> <span class="n">upd</span> <span class="k">=</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">PNCounter</span><span class="o">(),</span> <span class="n">writeTwo</span><span class="o">,</span> <span class="n">request</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">sender</span><span class="o">()))(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="n">upd</span>

  <span class="k">case</span> <span class="nc">UpdateSuccess</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="s">&quot;ack&quot;</span>
  <span class="k">case</span> <span class="nc">UpdateTimeout</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="s">&quot;nack&quot;</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="get">
<span id="replicator-get-scala"></span><h3>Get</h3>
<p>To retrieve the current value of a data you send <tt class="docutils literal"><span class="pre">Replicator.Get</span></tt> message to the
<tt class="docutils literal"><span class="pre">Replicator</span></tt>. You supply a consistency level which has the following meaning:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ReadLocal</span></tt> the value will only be read from the local replica</li>
<li><tt class="docutils literal"><span class="pre">ReadFrom(n)</span></tt> the value will be read and merged from <tt class="docutils literal"><span class="pre">n</span></tt> replicas,
including the local replica</li>
<li><tt class="docutils literal"><span class="pre">ReadMajority</span></tt> the value will be read and merged from a majority of replicas, i.e.
at least <strong>N/2 + 1</strong> replicas, where N is the number of nodes in the cluster
(or cluster role group)</li>
<li><tt class="docutils literal"><span class="pre">ReadAll</span></tt> the value will be read and merged from all nodes in the cluster
(or all nodes in the cluster role group)</li>
</ul>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>
<span class="k">val</span> <span class="nc">Counter1Key</span> <span class="k">=</span> <span class="nc">PNCounterKey</span><span class="o">(</span><span class="s">&quot;counter1&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Set1Key</span> <span class="k">=</span> <span class="nc">GSetKey</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;set1&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Set2Key</span> <span class="k">=</span> <span class="nc">ORSetKey</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;set2&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">ActiveFlagKey</span> <span class="k">=</span> <span class="nc">FlagKey</span><span class="o">(</span><span class="s">&quot;active&quot;</span><span class="o">)</span>

<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">ReadLocal</span><span class="o">)</span>

<span class="k">val</span> <span class="n">readFrom3</span> <span class="k">=</span> <span class="nc">ReadFrom</span><span class="o">(</span><span class="n">n</span> <span class="k">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">timeout</span> <span class="k">=</span> <span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="n">readFrom3</span><span class="o">)</span>

<span class="k">val</span> <span class="n">readMajority</span> <span class="k">=</span> <span class="nc">ReadMajority</span><span class="o">(</span><span class="n">timeout</span> <span class="k">=</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">Set2Key</span><span class="o">,</span> <span class="n">readMajority</span><span class="o">)</span>

<span class="k">val</span> <span class="n">readAll</span> <span class="k">=</span> <span class="nc">ReadAll</span><span class="o">(</span><span class="n">timeout</span> <span class="k">=</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">ActiveFlagKey</span><span class="o">,</span> <span class="n">readAll</span><span class="o">)</span>
</pre></div>
</div>
<p>As reply of the <tt class="docutils literal"><span class="pre">Get</span></tt> a <tt class="docutils literal"><span class="pre">Replicator.GetSuccess</span></tt> is sent to the sender of the
<tt class="docutils literal"><span class="pre">Get</span></tt> if the value was successfully retrieved according to the supplied consistency
level within the supplied timeout. Otherwise a <tt class="docutils literal"><span class="pre">Replicator.GetFailure</span></tt> is sent.
If the key does not exist the reply will be <tt class="docutils literal"><span class="pre">Replicator.NotFound</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="n">g</span> <span class="k">@</span> <span class="nc">GetSuccess</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">value</span> <span class="k">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">).</span><span class="n">value</span>
<span class="k">case</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// key counter1 does not exist</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="n">g</span> <span class="k">@</span> <span class="nc">GetSuccess</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">elements</span> <span class="k">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">).</span><span class="n">elements</span>
<span class="k">case</span> <span class="nc">GetFailure</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span> <span class="k">=&gt;</span>
<span class="c1">// read from 3 nodes failed within 1.second</span>
<span class="k">case</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nc">Set1Key</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="c1">// key set1 does not exist</span>
</pre></div>
</div>
<p>You will always read your own writes. For example if you send a <tt class="docutils literal"><span class="pre">Update</span></tt> message
followed by a <tt class="docutils literal"><span class="pre">Get</span></tt> of the same <tt class="docutils literal"><span class="pre">key</span></tt> the <tt class="docutils literal"><span class="pre">Get</span></tt> will retrieve the change that was
performed by the preceding <tt class="docutils literal"><span class="pre">Update</span></tt> message. However, the order of the reply messages are
not defined, i.e. in the previous example you may receive the <tt class="docutils literal"><span class="pre">GetSuccess</span></tt> before
the <tt class="docutils literal"><span class="pre">UpdateSuccess</span></tt>.</p>
<p>In the <tt class="docutils literal"><span class="pre">Get</span></tt> message you can pass an optional request context in the same way as for the
<tt class="docutils literal"><span class="pre">Update</span></tt> message, described above. For example the original sender can be passed and replied
to after receiving and transforming <tt class="docutils literal"><span class="pre">GetSuccess</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>
<span class="k">val</span> <span class="n">readTwo</span> <span class="k">=</span> <span class="nc">ReadFrom</span><span class="o">(</span><span class="n">n</span> <span class="k">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">timeout</span> <span class="k">=</span> <span class="mf">3.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Counter1Key</span> <span class="k">=</span> <span class="nc">PNCounterKey</span><span class="o">(</span><span class="s">&quot;counter1&quot;</span><span class="o">)</span>

<span class="k">def</span> <span class="n">receive</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">&quot;get-count&quot;</span> <span class="k">=&gt;</span>
    <span class="c1">// incoming request to retrieve current value of the counter</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="n">readTwo</span><span class="o">,</span> <span class="n">request</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">sender</span><span class="o">()))</span>

  <span class="k">case</span> <span class="n">g</span> <span class="k">@</span> <span class="nc">GetSuccess</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">value</span> <span class="k">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">).</span><span class="n">value</span><span class="o">.</span><span class="n">longValue</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="n">value</span>
  <span class="k">case</span> <span class="nc">GetFailure</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="o">-</span><span class="mi">1L</span>
  <span class="k">case</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="mi">0L</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="consistency">
<h3>Consistency</h3>
<p>The consistency level that is supplied in the <a class="reference internal" href="#replicator-update-scala"><em>Update</em></a> and <a class="reference internal" href="#replicator-get-scala"><em>Get</em></a>
specifies per request how many replicas that must respond successfully to a write and read request.</p>
<p>For low latency reads you use <tt class="docutils literal"><span class="pre">ReadLocal</span></tt> with the risk of retrieving stale data, i.e. updates
from other nodes might not be visible yet.</p>
<p>When using <tt class="docutils literal"><span class="pre">WriteLocal</span></tt> the update is only written to the local replica and then disseminated
in the background with the gossip protocol, which can take few seconds to spread to all nodes.</p>
<p><tt class="docutils literal"><span class="pre">WriteAll</span></tt> and <tt class="docutils literal"><span class="pre">ReadAll</span></tt> is the strongest consistency level, but also the slowest and with
lowest availability. For example, it is enough that one node is unavailable for a <tt class="docutils literal"><span class="pre">Get</span></tt> request
and you will not receive the value.</p>
<p>If consistency is important, you can ensure that a read always reflects the most recent
write by using the following formula:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="o">(</span><span class="n">nodes_written</span> <span class="o">+</span> <span class="n">nodes_read</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">N</span>
</pre></div>
</div>
<p>where N is the total number of nodes in the cluster, or the number of nodes with the role that is
used for the <tt class="docutils literal"><span class="pre">Replicator</span></tt>.</p>
<p>For example, in a 7 node cluster this these consistency properties are achieved by writing to 4 nodes
and reading from 4 nodes, or writing to 5 nodes and reading from 3 nodes.</p>
<p>By combining <tt class="docutils literal"><span class="pre">WriteMajority</span></tt> and <tt class="docutils literal"><span class="pre">ReadMajority</span></tt> levels a read always reflects the most recent write.
The <tt class="docutils literal"><span class="pre">Replicator</span></tt> writes and reads to a majority of replicas, i.e. <strong>N / 2 + 1</strong>. For example,
in a 5 node cluster it writes to 3 nodes and reads from 3 nodes. In a 6 node cluster it writes
to 4 nodes and reads from 4 nodes.</p>
<p>Here is an example of using <tt class="docutils literal"><span class="pre">WriteMajority</span></tt> and <tt class="docutils literal"><span class="pre">ReadMajority</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">private</span> <span class="k">val</span> <span class="n">timeout</span> <span class="k">=</span> <span class="mf">3.</span><span class="n">seconds</span>
<span class="k">private</span> <span class="k">val</span> <span class="n">readMajority</span> <span class="k">=</span> <span class="nc">ReadMajority</span><span class="o">(</span><span class="n">timeout</span><span class="o">)</span>
<span class="k">private</span> <span class="k">val</span> <span class="n">writeMajority</span> <span class="k">=</span> <span class="nc">WriteMajority</span><span class="o">(</span><span class="n">timeout</span><span class="o">)</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">def</span> <span class="n">receiveGetCart</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">GetCart</span> <span class="k">=&gt;</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="n">readMajority</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">sender</span><span class="o">()))</span>

  <span class="k">case</span> <span class="n">g</span> <span class="k">@</span> <span class="nc">GetSuccess</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">cart</span> <span class="k">=</span> <span class="nc">Cart</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">toSet</span><span class="o">)</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="n">cart</span>

  <span class="k">case</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">replyTo</span> <span class="o">!</span> <span class="nc">Cart</span><span class="o">(</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>

  <span class="k">case</span> <span class="nc">GetFailure</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="c1">// ReadMajority failure, try again with local read</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">ReadLocal</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">replyTo</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">def</span> <span class="n">receiveAddItem</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">cmd</span> <span class="k">@</span> <span class="nc">AddItem</span><span class="o">(</span><span class="n">item</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">update</span> <span class="k">=</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">LWWMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">LineItem</span><span class="o">],</span> <span class="n">writeMajority</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">cmd</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">cart</span> <span class="k">=&gt;</span> <span class="n">updateCart</span><span class="o">(</span><span class="n">cart</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="n">update</span>
<span class="o">}</span>
</pre></div>
</div>
<p>In some rare cases, when performing an <tt class="docutils literal"><span class="pre">Update</span></tt> it is needed to first try to fetch latest data from
other nodes. That can be done by first sending a <tt class="docutils literal"><span class="pre">Get</span></tt> with <tt class="docutils literal"><span class="pre">ReadMajority</span></tt> and then continue with
the <tt class="docutils literal"><span class="pre">Update</span></tt> when the <tt class="docutils literal"><span class="pre">GetSuccess</span></tt>, <tt class="docutils literal"><span class="pre">GetFailure</span></tt> or <tt class="docutils literal"><span class="pre">NotFound</span></tt> reply is received. This might be
needed when you need to base a decision on latest information or when removing entries from <tt class="docutils literal"><span class="pre">ORSet</span></tt>
or <tt class="docutils literal"><span class="pre">ORMap</span></tt>. If an entry is added to an <tt class="docutils literal"><span class="pre">ORSet</span></tt> or <tt class="docutils literal"><span class="pre">ORMap</span></tt> from one node and removed from another
node the entry will only be removed if the added entry is visible on the node where the removal is
performed (hence the name observed-removed set).</p>
<p>The following example illustrates how to do that:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">def</span> <span class="n">receiveRemoveItem</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">cmd</span> <span class="k">@</span> <span class="nc">RemoveItem</span><span class="o">(</span><span class="n">productId</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="c1">// Try to fetch latest from a majority of nodes first, since ORMap</span>
    <span class="c1">// remove must have seen the item to be able to remove it.</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="n">readMajority</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">cmd</span><span class="o">))</span>

  <span class="k">case</span> <span class="nc">GetSuccess</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">RemoveItem</span><span class="o">(</span><span class="n">productId</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">LWWMap</span><span class="o">(),</span> <span class="n">writeMajority</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">_</span> <span class="o">-</span> <span class="n">productId</span>
    <span class="o">}</span>

  <span class="k">case</span> <span class="nc">GetFailure</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">RemoveItem</span><span class="o">(</span><span class="n">productId</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="c1">// ReadMajority failed, fall back to best effort local value</span>
    <span class="n">replicator</span> <span class="o">!</span> <span class="nc">Update</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">LWWMap</span><span class="o">(),</span> <span class="n">writeMajority</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">_</span> <span class="o">-</span> <span class="n">productId</span>
    <span class="o">}</span>

  <span class="k">case</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nc">DataKey</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">RemoveItem</span><span class="o">(</span><span class="n">productId</span><span class="o">)))</span> <span class="k">=&gt;</span>
  <span class="c1">// nothing to remove</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><em>Caveat:</em> Even if you use <tt class="docutils literal"><span class="pre">WriteMajority</span></tt> and <tt class="docutils literal"><span class="pre">ReadMajority</span></tt> there is small risk that you may
read stale data if the cluster membership has changed between the <tt class="docutils literal"><span class="pre">Update</span></tt> and the <tt class="docutils literal"><span class="pre">Get</span></tt>.
For example, in cluster of 5 nodes when you <tt class="docutils literal"><span class="pre">Update</span></tt> and that change is written to 3 nodes:
n1, n2, n3. Then 2 more nodes are added and a <tt class="docutils literal"><span class="pre">Get</span></tt> request is reading from 4 nodes, which
happens to be n4, n5, n6, n7, i.e. the value on n1, n2, n3 is not seen in the response of the
<tt class="docutils literal"><span class="pre">Get</span></tt> request.</p>
</div>
</div>
<div class="section" id="subscribe">
<h3>Subscribe</h3>
<p>You may also register interest in change notifications by sending <tt class="docutils literal"><span class="pre">Replicator.Subscribe</span></tt>
message to the <tt class="docutils literal"><span class="pre">Replicator</span></tt>. It will send <tt class="docutils literal"><span class="pre">Replicator.Changed</span></tt> messages to the registered
subscriber when the data for the subscribed key is updated. Subscribers will be notified
periodically with the configured <tt class="docutils literal"><span class="pre">notify-subscribers-interval</span></tt>, and it is also possible to
send an explicit <tt class="docutils literal"><span class="pre">Replicator.FlushChanges</span></tt> message to the <tt class="docutils literal"><span class="pre">Replicator</span></tt> to notify the subscribers
immediately.</p>
<p>The subscriber is automatically removed if the subscriber is terminated. A subscriber can
also be deregistered with the <tt class="docutils literal"><span class="pre">Replicator.Unsubscribe</span></tt> message.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>
<span class="k">val</span> <span class="nc">Counter1Key</span> <span class="k">=</span> <span class="nc">PNCounterKey</span><span class="o">(</span><span class="s">&quot;counter1&quot;</span><span class="o">)</span>
<span class="c1">// subscribe to changes of the Counter1Key value</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Subscribe</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="n">self</span><span class="o">)</span>
<span class="k">var</span> <span class="n">currentValue</span> <span class="k">=</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="k">def</span> <span class="n">receive</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">c</span> <span class="k">@</span> <span class="nc">Changed</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">currentValue</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">).</span><span class="n">value</span>
  <span class="k">case</span> <span class="s">&quot;get-count&quot;</span> <span class="k">=&gt;</span>
    <span class="c1">// incoming request to retrieve current value of the counter</span>
    <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">currentValue</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="delete">
<h3>Delete</h3>
<p>A data entry can be deleted by sending a <tt class="docutils literal"><span class="pre">Replicator.Delete</span></tt> message to the local
local <tt class="docutils literal"><span class="pre">Replicator</span></tt>. As reply of the <tt class="docutils literal"><span class="pre">Delete</span></tt> a <tt class="docutils literal"><span class="pre">Replicator.DeleteSuccess</span></tt> is sent to
the sender of the <tt class="docutils literal"><span class="pre">Delete</span></tt> if the value was successfully deleted according to the supplied
consistency level within the supplied timeout. Otherwise a <tt class="docutils literal"><span class="pre">Replicator.ReplicationDeleteFailure</span></tt>
is sent. Note that <tt class="docutils literal"><span class="pre">ReplicationDeleteFailure</span></tt> does not mean that the delete completely failed or
was rolled back. It may still have been replicated to some nodes, and may eventually be replicated
to all nodes.</p>
<p>A deleted key cannot be reused again, but it is still recommended to delete unused
data entries because that reduces the replication overhead when new nodes join the cluster.
Subsequent <tt class="docutils literal"><span class="pre">Delete</span></tt>, <tt class="docutils literal"><span class="pre">Update</span></tt> and <tt class="docutils literal"><span class="pre">Get</span></tt> requests will be replied with <tt class="docutils literal"><span class="pre">Replicator.DataDeleted</span></tt>.
Subscribers will receive <tt class="docutils literal"><span class="pre">Replicator.DataDeleted</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">replicator</span> <span class="k">=</span> <span class="nc">DistributedData</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">replicator</span>
<span class="k">val</span> <span class="nc">Counter1Key</span> <span class="k">=</span> <span class="nc">PNCounterKey</span><span class="o">(</span><span class="s">&quot;counter1&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="nc">Set2Key</span> <span class="k">=</span> <span class="nc">ORSetKey</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;set2&quot;</span><span class="o">)</span>

<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Delete</span><span class="o">(</span><span class="nc">Counter1Key</span><span class="o">,</span> <span class="nc">WriteLocal</span><span class="o">)</span>

<span class="k">val</span> <span class="n">writeMajority</span> <span class="k">=</span> <span class="nc">WriteMajority</span><span class="o">(</span><span class="n">timeout</span> <span class="k">=</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="n">replicator</span> <span class="o">!</span> <span class="nc">Delete</span><span class="o">(</span><span class="nc">Set2Key</span><span class="o">,</span> <span class="n">writeMajority</span><span class="o">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">As deleted keys continue to be included in the stored data on each node as well as in gossip
messages, a continuous series of updates and deletes of top-level entities will result in
growing memory usage until an ActorSystem runs out of memory. To use Akka Distributed Data
where frequent adds and removes are required, you should use a fixed number of top-level data
types that support both updates and removals, for example <tt class="docutils literal"><span class="pre">ORMap</span></tt> or <tt class="docutils literal"><span class="pre">ORSet</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="data-types">
<h2>Data Types</h2>
<p>The data types must be convergent (stateful) CRDTs and implement the <tt class="docutils literal"><span class="pre">ReplicatedData</span></tt> trait,
i.e. they provide a monotonic merge function and the state changes always converge.</p>
<p>You can use your own custom <tt class="docutils literal"><span class="pre">ReplicatedData</span></tt> types, and several types are provided
by this package, such as:</p>
<ul class="simple">
<li>Counters: <tt class="docutils literal"><span class="pre">GCounter</span></tt>, <tt class="docutils literal"><span class="pre">PNCounter</span></tt></li>
<li>Sets: <tt class="docutils literal"><span class="pre">GSet</span></tt>, <tt class="docutils literal"><span class="pre">ORSet</span></tt></li>
<li>Maps: <tt class="docutils literal"><span class="pre">ORMap</span></tt>, <tt class="docutils literal"><span class="pre">ORMultiMap</span></tt>, <tt class="docutils literal"><span class="pre">LWWMap</span></tt>, <tt class="docutils literal"><span class="pre">PNCounterMap</span></tt></li>
<li>Registers: <tt class="docutils literal"><span class="pre">LWWRegister</span></tt>, <tt class="docutils literal"><span class="pre">Flag</span></tt></li>
</ul>
<div class="section" id="counters">
<h3>Counters</h3>
<p><tt class="docutils literal"><span class="pre">GCounter</span></tt> is a &quot;grow only counter&quot;. It only supports increments, no decrements.</p>
<p>It works in a similar way as a vector clock. It keeps track of one counter per node and the total
value is the sum of these counters. The <tt class="docutils literal"><span class="pre">merge</span></tt> is implemented by taking the maximum count for
each node.</p>
<p>If you need both increments and decrements you can use the <tt class="docutils literal"><span class="pre">PNCounter</span></tt> (positive/negative counter).</p>
<p>It is tracking the increments (P) separate from the decrements (N). Both P and N are represented
as two internal <tt class="docutils literal"><span class="pre">GCounter</span></tt>. Merge is handled by merging the internal P and N counters.
The value of the counter is the value of the P counter minus the value of the N counter.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">c0</span> <span class="k">=</span> <span class="nc">PNCounter</span><span class="o">.</span><span class="n">empty</span>
<span class="k">val</span> <span class="n">c1</span> <span class="k">=</span> <span class="n">c0</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">val</span> <span class="n">c2</span> <span class="k">=</span> <span class="n">c1</span> <span class="o">+</span> <span class="mi">7</span>
<span class="k">val</span> <span class="n">c3</span><span class="k">:</span> <span class="kt">PNCounter</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="mi">2</span>
<span class="n">println</span><span class="o">(</span><span class="n">c3</span><span class="o">.</span><span class="n">value</span><span class="o">)</span> <span class="c1">// 6</span>
</pre></div>
</div>
<p>Several related counters can be managed in a map with the <tt class="docutils literal"><span class="pre">PNCounterMap</span></tt> data type.
When the counters are placed in a <tt class="docutils literal"><span class="pre">PNCounterMap</span></tt> as opposed to placing them as separate top level
values they are guaranteed to be replicated together as one unit, which is sometimes necessary for
related data.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m0</span> <span class="k">=</span> <span class="nc">PNCounterMap</span><span class="o">.</span><span class="n">empty</span>
<span class="k">val</span> <span class="n">m1</span> <span class="k">=</span> <span class="n">m0</span><span class="o">.</span><span class="n">increment</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m2</span> <span class="k">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">decrement</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m3</span> <span class="k">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">increment</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">m3</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">))</span> <span class="c1">// 5</span>
<span class="n">m3</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;$key -&gt; $value&quot;</span><span class="o">)</span> <span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sets">
<h3>Sets</h3>
<p>If you only need to add elements to a set and not remove elements the <tt class="docutils literal"><span class="pre">GSet</span></tt> (grow-only set) is
the data type to use. The elements can be any type of values that can be serialized.
Merge is simply the union of the two sets.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">s0</span> <span class="k">=</span> <span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">val</span> <span class="n">s1</span> <span class="k">=</span> <span class="n">s0</span> <span class="o">+</span> <span class="s">&quot;a&quot;</span>
<span class="k">val</span> <span class="n">s2</span> <span class="k">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">&quot;b&quot;</span> <span class="o">+</span> <span class="s">&quot;c&quot;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">))</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="n">elements</span><span class="o">)</span> <span class="c1">// a, b, c</span>
</pre></div>
</div>
<p>If you need add and remove operations you should use the <tt class="docutils literal"><span class="pre">ORSet</span></tt> (observed-remove set).
Elements can be added and removed any number of times. If an element is concurrently added and
removed, the add will win. You cannot remove an element that you have not seen.</p>
<p>The <tt class="docutils literal"><span class="pre">ORSet</span></tt> has a version vector that is incremented when an element is added to the set.
The version for the node that added the element is also tracked for each element in a so
called &quot;birth dot&quot;. The version vector and the dots are used by the <tt class="docutils literal"><span class="pre">merge</span></tt> function to
track causality of the operations and resolve concurrent updates.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">s0</span> <span class="k">=</span> <span class="nc">ORSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">val</span> <span class="n">s1</span> <span class="k">=</span> <span class="n">s0</span> <span class="o">+</span> <span class="s">&quot;a&quot;</span>
<span class="k">val</span> <span class="n">s2</span> <span class="k">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">&quot;b&quot;</span>
<span class="k">val</span> <span class="n">s3</span> <span class="k">=</span> <span class="n">s2</span> <span class="o">-</span> <span class="s">&quot;a&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="n">s3</span><span class="o">.</span><span class="n">elements</span><span class="o">)</span> <span class="c1">// b</span>
</pre></div>
</div>
</div>
<div class="section" id="maps">
<h3>Maps</h3>
<p><tt class="docutils literal"><span class="pre">ORMap</span></tt> (observed-remove map) is a map with <tt class="docutils literal"><span class="pre">String</span></tt> keys and the values are <tt class="docutils literal"><span class="pre">ReplicatedData</span></tt>
types themselves. It supports add, remove and delete any number of times for a map entry.</p>
<p>If an entry is concurrently added and removed, the add will win. You cannot remove an entry that
you have not seen. This is the same semantics as for the <tt class="docutils literal"><span class="pre">ORSet</span></tt>.</p>
<p>If an entry is concurrently updated to different values the values will be merged, hence the
requirement that the values must be <tt class="docutils literal"><span class="pre">ReplicatedData</span></tt> types.</p>
<p>It is rather inconvenient to use the <tt class="docutils literal"><span class="pre">ORMap</span></tt> directly since it does not expose specific types
of the values. The <tt class="docutils literal"><span class="pre">ORMap</span></tt> is intended as a low level tool for building more specific maps,
such as the following specialized maps.</p>
<p><tt class="docutils literal"><span class="pre">ORMultiMap</span></tt> (observed-remove multi-map) is a multi-map implementation that wraps an
<tt class="docutils literal"><span class="pre">ORMap</span></tt> with an <tt class="docutils literal"><span class="pre">ORSet</span></tt> for the map's value.</p>
<p><tt class="docutils literal"><span class="pre">PNCounterMap</span></tt> (positive negative counter map) is a map of named counters. It is a specialized
<tt class="docutils literal"><span class="pre">ORMap</span></tt> with <tt class="docutils literal"><span class="pre">PNCounter</span></tt> values.</p>
<p><tt class="docutils literal"><span class="pre">LWWMap</span></tt> (last writer wins map) is a specialized <tt class="docutils literal"><span class="pre">ORMap</span></tt> with <tt class="docutils literal"><span class="pre">LWWRegister</span></tt> (last writer wins register)
values.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m0</span> <span class="k">=</span> <span class="nc">ORMultiMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="k">val</span> <span class="n">m1</span> <span class="k">=</span> <span class="n">m0</span> <span class="o">+</span> <span class="o">(</span><span class="s">&quot;a&quot;</span> <span class="o">-&gt;</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="k">val</span> <span class="n">m2</span> <span class="k">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">addBinding</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m3</span> <span class="k">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">removeBinding</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">m4</span> <span class="k">=</span> <span class="n">m3</span><span class="o">.</span><span class="n">addBinding</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">m4</span><span class="o">.</span><span class="n">entries</span><span class="o">)</span>
</pre></div>
</div>
<p>When a data entry is changed the full state of that entry is replicated to other nodes, i.e.
when you update a map the whole map is replicated. Therefore, instead of using one <tt class="docutils literal"><span class="pre">ORMap</span></tt>
with 1000 elements it is more efficient to split that up in 10 top level <tt class="docutils literal"><span class="pre">ORMap</span></tt> entries
with 100 elements each. Top level entries are replicated individually, which has the
trade-off that different entries may not be replicated at the same time and you may see
inconsistencies between related entries. Separate top level entries cannot be updated atomically
together.</p>
<p>Note that <tt class="docutils literal"><span class="pre">LWWRegister</span></tt> and therefore <tt class="docutils literal"><span class="pre">LWWMap</span></tt> relies on synchronized clocks and should only be used
when the choice of value is not important for concurrent updates occurring within the clock skew. Read more
in the below section about <tt class="docutils literal"><span class="pre">LWWRegister</span></tt>.</p>
</div>
<div class="section" id="flags-and-registers">
<h3>Flags and Registers</h3>
<p><tt class="docutils literal"><span class="pre">Flag</span></tt> is a data type for a boolean value that is initialized to <tt class="docutils literal"><span class="pre">false</span></tt> and can be switched
to <tt class="docutils literal"><span class="pre">true</span></tt>. Thereafter it cannot be changed. <tt class="docutils literal"><span class="pre">true</span></tt> wins over <tt class="docutils literal"><span class="pre">false</span></tt> in merge.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">f0</span> <span class="k">=</span> <span class="nc">Flag</span><span class="o">.</span><span class="n">empty</span>
<span class="k">val</span> <span class="n">f1</span> <span class="k">=</span> <span class="n">f0</span><span class="o">.</span><span class="n">switchOn</span>
<span class="n">println</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="n">enabled</span><span class="o">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">LWWRegister</span></tt> (last writer wins register) can hold any (serializable) value.</p>
<p>Merge of a <tt class="docutils literal"><span class="pre">LWWRegister</span></tt> takes the register with highest timestamp. Note that this
relies on synchronized clocks. <cite>LWWRegister</cite> should only be used when the choice of
value is not important for concurrent updates occurring within the clock skew.</p>
<p>Merge takes the register updated by the node with lowest address (<tt class="docutils literal"><span class="pre">UniqueAddress</span></tt> is ordered)
if the timestamps are exactly the same.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="nc">LWWRegister</span><span class="o">(</span><span class="s">&quot;Hello&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">withValue</span><span class="o">(</span><span class="s">&quot;Hi&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;${r1.value} by ${r1.updatedBy} at ${r1.timestamp}&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>Instead of using timestamps based on <tt class="docutils literal"><span class="pre">System.currentTimeMillis()</span></tt> time it is possible to
use a timestamp value based on something else, for example an increasing version number
from a database record that is used for optimistic concurrency control.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">Record</span><span class="o">(</span><span class="n">version</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">address</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">recordClock</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">LWWRegister</span><span class="o">.</span><span class="nc">Clock</span><span class="o">[</span><span class="kt">Record</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">currentTimestamp</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Record</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span>
    <span class="n">value</span><span class="o">.</span><span class="n">version</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">record1</span> <span class="k">=</span> <span class="nc">Record</span><span class="o">(</span><span class="n">version</span> <span class="k">=</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;Alice&quot;</span><span class="o">,</span> <span class="s">&quot;Union Square&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="nc">LWWRegister</span><span class="o">(</span><span class="n">record1</span><span class="o">)</span>

<span class="k">val</span> <span class="n">record2</span> <span class="k">=</span> <span class="nc">Record</span><span class="o">(</span><span class="n">version</span> <span class="k">=</span> <span class="mi">2</span><span class="o">,</span> <span class="s">&quot;Alice&quot;</span><span class="o">,</span> <span class="s">&quot;Madison Square&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="nc">LWWRegister</span><span class="o">(</span><span class="n">record2</span><span class="o">)</span>

<span class="k">val</span> <span class="n">r3</span> <span class="k">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">r2</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">r3</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
</pre></div>
</div>
<p>For first-write-wins semantics you can use the <tt class="docutils literal"><span class="pre">LWWRegister#reverseClock</span></tt> instead of the
<tt class="docutils literal"><span class="pre">LWWRegister#defaultClock</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">defaultClock</span></tt> is using max value of <tt class="docutils literal"><span class="pre">System.currentTimeMillis()</span></tt> and <tt class="docutils literal"><span class="pre">currentTimestamp</span> <span class="pre">+</span> <span class="pre">1</span></tt>.
This means that the timestamp is increased for changes on the same node that occurs within
the same millisecond. It also means that it is safe to use the <tt class="docutils literal"><span class="pre">LWWRegister</span></tt> without
synchronized clocks when there is only one active writer, e.g. a Cluster Singleton. Such a
single writer should then first read current value with <tt class="docutils literal"><span class="pre">ReadMajority</span></tt> (or more) before
changing and writing the value with <tt class="docutils literal"><span class="pre">WriteMajority</span></tt> (or more).</p>
</div>
<div class="section" id="custom-data-type">
<h3>Custom Data Type</h3>
<p>You can rather easily implement your own data types. The only requirement is that it implements
the <tt class="docutils literal"><span class="pre">merge</span></tt> function of the <tt class="docutils literal"><span class="pre">ReplicatedData</span></tt> trait.</p>
<p>A nice property of stateful CRDTs is that they typically compose nicely, i.e. you can combine several
smaller data types to build richer data structures. For example, the <tt class="docutils literal"><span class="pre">PNCounter</span></tt> is composed of
two internal <tt class="docutils literal"><span class="pre">GCounter</span></tt> instances to keep track of increments and decrements separately.</p>
<p>Here is s simple implementation of a custom <tt class="docutils literal"><span class="pre">TwoPhaseSet</span></tt> that is using two internal <tt class="docutils literal"><span class="pre">GSet</span></tt> types
to keep track of addition and removals.  A <tt class="docutils literal"><span class="pre">TwoPhaseSet</span></tt> is a set where an element may be added and
removed, but never added again thereafter.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">TwoPhaseSet</span><span class="o">(</span>
  <span class="n">adds</span><span class="k">:</span>     <span class="kt">GSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">,</span>
  <span class="n">removals</span><span class="k">:</span> <span class="kt">GSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">ReplicatedData</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">TwoPhaseSet</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">element</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=</span>
    <span class="n">copy</span><span class="o">(</span><span class="n">adds</span> <span class="k">=</span> <span class="n">adds</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">element</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">element</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=</span>
    <span class="n">copy</span><span class="o">(</span><span class="n">removals</span> <span class="k">=</span> <span class="n">removals</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">element</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">elements</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">adds</span><span class="o">.</span><span class="n">elements</span> <span class="n">diff</span> <span class="n">removals</span><span class="o">.</span><span class="n">elements</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=</span>
    <span class="n">copy</span><span class="o">(</span>
      <span class="n">adds</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">adds</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">adds</span><span class="o">),</span>
      <span class="n">removals</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">removals</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">removals</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Data types should be immutable, i.e. &quot;modifying&quot; methods should return a new instance.</p>
<div class="section" id="serialization">
<h4>Serialization</h4>
<p>The data types must be serializable with an <a class="reference internal" href="serialization.html#serialization-scala"><em>Akka Serializer</em></a>.
It is highly recommended that you implement  efficient serialization with Protobuf or similar
for your custom data types. The built in data types are marked with <tt class="docutils literal"><span class="pre">ReplicatedDataSerialization</span></tt>
and serialized with <tt class="docutils literal"><span class="pre">akka.cluster.ddata.protobuf.ReplicatedDataSerializer</span></tt>.</p>
<p>Serialization of the data types are used in remote messages and also for creating message
digests (SHA-1) to detect changes. Therefore it is important that the serialization is efficient
and produce the same bytes for the same content. For example sets and maps should be sorted
deterministically in the serialization.</p>
<p>This is a protobuf representation of the above <tt class="docutils literal"><span class="pre">TwoPhaseSet</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">option</span> <span class="n">java_package</span> <span class="k">=</span> <span class="s">&quot;docs.ddata.protobuf.msg&quot;</span><span class="o">;</span>
<span class="n">option</span> <span class="n">optimize_for</span> <span class="k">=</span> <span class="nc">SPEED</span><span class="o">;</span>

<span class="n">message</span> <span class="nc">TwoPhaseSet</span> <span class="o">{</span>
  <span class="n">repeated</span> <span class="n">string</span> <span class="n">adds</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">repeated</span> <span class="n">string</span> <span class="n">removals</span> <span class="k">=</span> <span class="mi">2</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The serializer for the <tt class="docutils literal"><span class="pre">TwoPhaseSet</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">java.util.ArrayList</span>
<span class="k">import</span> <span class="nn">java.util.Collections</span>
<span class="k">import</span> <span class="nn">scala.collection.JavaConverters._</span>
<span class="k">import</span> <span class="nn">akka.actor.ExtendedActorSystem</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.GSet</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.protobuf.SerializationSupport</span>
<span class="k">import</span> <span class="nn">akka.serialization.Serializer</span>
<span class="k">import</span> <span class="nn">docs.ddata.TwoPhaseSet</span>
<span class="k">import</span> <span class="nn">docs.ddata.protobuf.msg.TwoPhaseSetMessages</span>

<span class="k">class</span> <span class="nc">TwoPhaseSetSerializer</span><span class="o">(</span><span class="k">val</span> <span class="n">system</span><span class="k">:</span> <span class="kt">ExtendedActorSystem</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">Serializer</span> <span class="k">with</span> <span class="nc">SerializationSupport</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">includeManifest</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">identifier</span> <span class="k">=</span> <span class="mi">99999</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span> <span class="k">=</span> <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=&gt;</span> <span class="n">twoPhaseSetToProto</span><span class="o">(</span><span class="n">m</span><span class="o">).</span><span class="n">toByteArray</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span>
      <span class="n">s</span><span class="s">&quot;Can&#39;t serialize object of type ${obj.getClass}&quot;</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">clazz</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">AnyRef</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">twoPhaseSetFromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">twoPhaseSetToProto</span><span class="o">(</span><span class="n">twoPhaseSet</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">TwoPhaseSetMessages.TwoPhaseSet</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="nc">TwoPhaseSetMessages</span><span class="o">.</span><span class="nc">TwoPhaseSet</span><span class="o">.</span><span class="n">newBuilder</span><span class="o">()</span>
    <span class="c1">// using java collections and sorting for performance (avoid conversions)</span>
    <span class="k">val</span> <span class="n">adds</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="n">twoPhaseSet</span><span class="o">.</span><span class="n">adds</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">adds</span><span class="o">.</span><span class="n">add</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">adds</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Collections</span><span class="o">.</span><span class="n">sort</span><span class="o">(</span><span class="n">adds</span><span class="o">)</span>
      <span class="n">b</span><span class="o">.</span><span class="n">addAllAdds</span><span class="o">(</span><span class="n">adds</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="k">val</span> <span class="n">removals</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="n">twoPhaseSet</span><span class="o">.</span><span class="n">removals</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">removals</span><span class="o">.</span><span class="n">add</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">removals</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Collections</span><span class="o">.</span><span class="n">sort</span><span class="o">(</span><span class="n">removals</span><span class="o">)</span>
      <span class="n">b</span><span class="o">.</span><span class="n">addAllRemovals</span><span class="o">(</span><span class="n">removals</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">b</span><span class="o">.</span><span class="n">build</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">twoPhaseSetFromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">msg</span> <span class="k">=</span> <span class="nc">TwoPhaseSetMessages</span><span class="o">.</span><span class="nc">TwoPhaseSet</span><span class="o">.</span><span class="n">parseFrom</span><span class="o">(</span><span class="n">bytes</span><span class="o">)</span>
    <span class="nc">TwoPhaseSet</span><span class="o">(</span>
      <span class="n">adds</span> <span class="k">=</span> <span class="nc">GSet</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">getAddsList</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">asScala</span><span class="o">.</span><span class="n">toSet</span><span class="o">),</span>
      <span class="n">removals</span> <span class="k">=</span> <span class="nc">GSet</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">getRemovalsList</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">asScala</span><span class="o">.</span><span class="n">toSet</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note that the elements of the sets are sorted so the SHA-1 digests are the same
for the same elements.</p>
<p>You register the serializer in configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">actor</span> <span class="o">{</span>
  <span class="n">serializers</span> <span class="o">{</span>
    <span class="n">two</span><span class="o">-</span><span class="n">phase</span><span class="o">-</span><span class="n">set</span> <span class="k">=</span> <span class="s">&quot;docs.ddata.protobuf.TwoPhaseSetSerializer&quot;</span>
  <span class="o">}</span>
  <span class="n">serialization</span><span class="o">-</span><span class="n">bindings</span> <span class="o">{</span>
    <span class="s">&quot;docs.ddata.TwoPhaseSet&quot;</span> <span class="k">=</span> <span class="n">two</span><span class="o">-</span><span class="n">phase</span><span class="o">-</span><span class="n">set</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Using compression can sometimes be a good idea to reduce the data size. Gzip compression is
provided by the <tt class="docutils literal"><span class="pre">akka.cluster.ddata.protobuf.SerializationSupport</span></tt> trait:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span> <span class="k">=</span> <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=&gt;</span> <span class="n">compress</span><span class="o">(</span><span class="n">twoPhaseSetToProto</span><span class="o">(</span><span class="n">m</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span>
    <span class="n">s</span><span class="s">&quot;Can&#39;t serialize object of type ${obj.getClass}&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">override</span> <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">clazz</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">AnyRef</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">twoPhaseSetFromBinary</span><span class="o">(</span><span class="n">decompress</span><span class="o">(</span><span class="n">bytes</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The two embedded <tt class="docutils literal"><span class="pre">GSet</span></tt> can be serialized as illustrated above, but in general when composing
new data types from the existing built in types it is better to make use of the existing
serializer for those types. This can be done by declaring those as bytes fields in protobuf:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">message</span> <span class="nc">TwoPhaseSet2</span> <span class="o">{</span>
  <span class="n">optional</span> <span class="n">bytes</span> <span class="n">adds</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">optional</span> <span class="n">bytes</span> <span class="n">removals</span> <span class="k">=</span> <span class="mi">2</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>and use the methods <tt class="docutils literal"><span class="pre">otherMessageToProto</span></tt> and <tt class="docutils literal"><span class="pre">otherMessageFromBinary</span></tt> that are provided
by the <tt class="docutils literal"><span class="pre">SerializationSupport</span></tt> trait to serialize and deserialize the <tt class="docutils literal"><span class="pre">GSet</span></tt> instances. This
works with any type that has a registered Akka serializer. This is how such an serializer would
look like for the <tt class="docutils literal"><span class="pre">TwoPhaseSet</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ExtendedActorSystem</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.GSet</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.protobuf.ReplicatedDataSerializer</span>
<span class="k">import</span> <span class="nn">akka.cluster.ddata.protobuf.SerializationSupport</span>
<span class="k">import</span> <span class="nn">akka.serialization.Serializer</span>
<span class="k">import</span> <span class="nn">docs.ddata.TwoPhaseSet</span>
<span class="k">import</span> <span class="nn">docs.ddata.protobuf.msg.TwoPhaseSetMessages</span>

<span class="k">class</span> <span class="nc">TwoPhaseSetSerializer2</span><span class="o">(</span><span class="k">val</span> <span class="n">system</span><span class="k">:</span> <span class="kt">ExtendedActorSystem</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">Serializer</span> <span class="k">with</span> <span class="nc">SerializationSupport</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">includeManifest</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">identifier</span> <span class="k">=</span> <span class="mi">99999</span>

  <span class="k">val</span> <span class="n">replicatedDataSerializer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ReplicatedDataSerializer</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span> <span class="k">=</span> <span class="n">obj</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=&gt;</span> <span class="n">twoPhaseSetToProto</span><span class="o">(</span><span class="n">m</span><span class="o">).</span><span class="n">toByteArray</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span>
      <span class="n">s</span><span class="s">&quot;Can&#39;t serialize object of type ${obj.getClass}&quot;</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">clazz</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">AnyRef</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">twoPhaseSetFromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">twoPhaseSetToProto</span><span class="o">(</span><span class="n">twoPhaseSet</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">TwoPhaseSetMessages.TwoPhaseSet2</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="nc">TwoPhaseSetMessages</span><span class="o">.</span><span class="nc">TwoPhaseSet2</span><span class="o">.</span><span class="n">newBuilder</span><span class="o">()</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">twoPhaseSet</span><span class="o">.</span><span class="n">adds</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
      <span class="n">b</span><span class="o">.</span><span class="n">setAdds</span><span class="o">(</span><span class="n">otherMessageToProto</span><span class="o">(</span><span class="n">twoPhaseSet</span><span class="o">.</span><span class="n">adds</span><span class="o">).</span><span class="n">toByteString</span><span class="o">())</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">twoPhaseSet</span><span class="o">.</span><span class="n">removals</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
      <span class="n">b</span><span class="o">.</span><span class="n">setRemovals</span><span class="o">(</span><span class="n">otherMessageToProto</span><span class="o">(</span><span class="n">twoPhaseSet</span><span class="o">.</span><span class="n">removals</span><span class="o">).</span><span class="n">toByteString</span><span class="o">())</span>
    <span class="n">b</span><span class="o">.</span><span class="n">build</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">twoPhaseSetFromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span><span class="k">:</span> <span class="kt">TwoPhaseSet</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">msg</span> <span class="k">=</span> <span class="nc">TwoPhaseSetMessages</span><span class="o">.</span><span class="nc">TwoPhaseSet2</span><span class="o">.</span><span class="n">parseFrom</span><span class="o">(</span><span class="n">bytes</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">adds</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">hasAdds</span><span class="o">)</span>
        <span class="n">otherMessageFromBinary</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">getAdds</span><span class="o">.</span><span class="n">toByteArray</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">GSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
      <span class="k">else</span>
        <span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">removals</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">hasRemovals</span><span class="o">)</span>
        <span class="n">otherMessageFromBinary</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">getRemovals</span><span class="o">.</span><span class="n">toByteArray</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">GSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
      <span class="k">else</span>
        <span class="nc">GSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="nc">TwoPhaseSet</span><span class="o">(</span><span class="n">adds</span><span class="o">,</span> <span class="n">removals</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="durable-storage">
<h3>Durable Storage</h3>
<p>By default the data is only kept in memory. It is redundant since it is replicated to other nodes
in the cluster, but if you stop all nodes the data is lost, unless you have saved it
elsewhere.</p>
<p>Entries can be configured to be durable, i.e. stored on local disk on each node. The stored data will be loaded
next time the replicator is started, i.e. when actor system is restarted. This means data will survive as
long as at least one node from the old cluster takes part in a new cluster. The keys of the durable entries
are configured with:</p>
<div class="highlight-scala"><pre>akka.cluster.distributed-data.durable.keys = ["a", "b", "durable*"]</pre>
</div>
<p>Prefix matching is supported by using <tt class="docutils literal"><span class="pre">*</span></tt> at the end of a key.</p>
<p>All entries can be made durable by specifying:</p>
<div class="highlight-scala"><pre>akka.cluster.distributed-data.durable.keys = ["*"]</pre>
</div>
<p><a class="reference external" href="https://symas.com/products/lightning-memory-mapped-database/">LMDB</a> is the default storage implementation. It is
possible to replace that with another implementation by implementing the actor protocol described in
<tt class="docutils literal"><span class="pre">akka.cluster.ddata.DurableStore</span></tt> and defining the <tt class="docutils literal"><span class="pre">akka.cluster.distributed-data.durable.store-actor-class</span></tt>
property for the new implementation.</p>
<p>The location of the files for the data is configured with:</p>
<div class="highlight-scala"><pre># Directory of LMDB file. There are two options:
# 1. A relative or absolute path to a directory that ends with 'ddata'
#    the full name of the directory will contain name of the ActorSystem
#    and its remote port.
# 2. Otherwise the path is used as is, as a relative or absolute path to
#    a directory.
akka.cluster.distributed-data.durable.lmdb.dir = "ddata"</pre>
</div>
<p>Making the data durable has of course a performance cost. By default, each update is flushed
to disk before the <tt class="docutils literal"><span class="pre">UpdateSuccess</span></tt> reply is sent. For better performance, but with the risk of losing
the last writes if the JVM crashes, you can enable write behind mode. Changes are then accumulated during
a time period before it is written to LMDB and flushed to disk. Enabling write behind is especially
efficient when performing many writes to the same key, because it is only the last value for each key
that will be serialized and stored. The risk of losing writes if the JVM crashes is small since the
data is typically replicated to other nodes immediately according to the given <tt class="docutils literal"><span class="pre">WriteConsistency</span></tt>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">distributed</span><span class="o">-</span><span class="n">data</span><span class="o">.</span><span class="n">lmdb</span><span class="o">.</span><span class="n">write</span><span class="o">-</span><span class="n">behind</span><span class="o">-</span><span class="n">interval</span> <span class="k">=</span> <span class="mi">200</span> <span class="n">ms</span>
</pre></div>
</div>
<p>Note that you should be prepared to receive <tt class="docutils literal"><span class="pre">WriteFailure</span></tt> as reply to an <tt class="docutils literal"><span class="pre">Update</span></tt> of a
durable entry if the data could not be stored for some reason. When enabling <tt class="docutils literal"><span class="pre">write-behind-interval</span></tt>
such errors will only be logged and <tt class="docutils literal"><span class="pre">UpdateSuccess</span></tt> will still be the reply to the <tt class="docutils literal"><span class="pre">Update</span></tt>.</p>
</div>
<div class="section" id="crdt-garbage">
<h3>CRDT Garbage</h3>
<p>One thing that can be problematic with CRDTs is that some data types accumulate history (garbage).
For example a <tt class="docutils literal"><span class="pre">GCounter</span></tt> keeps track of one counter per node. If a <tt class="docutils literal"><span class="pre">GCounter</span></tt> has been updated
from one node it will associate the identifier of that node forever. That can become a problem
for long running systems with many cluster nodes being added and removed. To solve this problem
the <tt class="docutils literal"><span class="pre">Replicator</span></tt> performs pruning of data associated with nodes that have been removed from the
cluster. Data types that need pruning have to implement the <tt class="docutils literal"><span class="pre">RemovedNodePruning</span></tt> trait.</p>
</div>
</div>
<div class="section" id="samples">
<h2>Samples</h2>
<p>Several interesting samples are included and described in the <a class="reference external" href="http://www.lightbend.com/platform/getstarted">Lightbend Activator</a>
tutorial named <a class="reference external" href="http://www.lightbend.com/activator/template/akka-sample-distributed-data-scala">Akka Distributed Data Samples with Scala</a>.</p>
<ul class="simple">
<li>Low Latency Voting Service</li>
<li>Highly Available Shopping Cart</li>
<li>Distributed Service Registry</li>
<li>Replicated Cache</li>
<li>Replicated Metrics</li>
</ul>
</div>
<div class="section" id="limitations">
<h2>Limitations</h2>
<p>There are some limitations that you should be aware of.</p>
<p>CRDTs cannot be used for all types of problems, and eventual consistency does not fit
all domains. Sometimes you need strong consistency.</p>
<p>It is not intended for <em>Big Data</em>. The number of top level entries should not exceed 100000.
When a new node is added to the cluster all these entries are transferred (gossiped) to the
new node. The entries are split up in chunks and all existing nodes collaborate in the gossip,
but it will take a while (tens of seconds) to transfer all entries and this means that you
cannot have too many top level entries. The current recommended limit is 100000. We will
be able to improve this if needed, but the design is still not intended for billions of entries.</p>
<p>All data is held in memory, which is another reason why it is not intended for <em>Big Data</em>.</p>
<p>When a data entry is changed the full state of that entry is replicated to other nodes. For example,
if you add one element to a Set with 100 existing elements, all 101 elements are transferred to
other nodes. This means that you cannot have too large data entries, because then the remote message
size will be too large. We might be able to make this more efficient by implementing
<a class="reference external" href="http://gsd.di.uminho.pt/members/cbm/ps/delta-crdt-draft16may2014.pdf">Efficient State-based CRDTs by Delta-Mutation</a>.</p>
</div>
<div class="section" id="learn-more-about-crdts">
<h2>Learn More about CRDTs</h2>
<ul class="simple">
<li><a class="reference external" href="http://www.ustream.tv/recorded/61448875">The Final Causal Frontier</a>
talk by Sean Cribbs</li>
<li><a class="reference external" href="https://vimeo.com/43903960">Eventually Consistent Data Structures</a>
talk by Sean Cribbs</li>
<li><a class="reference external" href="http://research.microsoft.com/apps/video/default.aspx?id=153540&amp;r=1">Strong Eventual Consistency and Conflict-free Replicated Data Types</a>
talk by Mark Shapiro</li>
<li><a class="reference external" href="http://hal.upmc.fr/file/index/docid/555588/filename/techreport.pdf">A comprehensive study of Convergent and Commutative Replicated Data Types</a>
paper by Mark Shapiro et. al.</li>
</ul>
<div class="section" id="dependencies">
<h3>Dependencies</h3>
<p>To use Distributed Data you must add the following dependency in your project.</p>
<p>sbt:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-distributed-data-experimental&quot;</span> <span class="o">%</span> <span class="s">&quot;2.4.20&quot;</span>
</pre></div>
</div>
<p>maven:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="o">&lt;</span><span class="n">dependency</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="n">com</span><span class="o">.</span><span class="n">typesafe</span><span class="o">.</span><span class="n">akka</span><span class="o">&lt;/</span><span class="n">groupId</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">akka</span><span class="o">-</span><span class="n">distributed</span><span class="o">-</span><span class="n">data</span><span class="o">-</span><span class="n">experimental_2</span><span class="o">.</span><span class="mi">11</span><span class="o">&lt;/</span><span class="n">artifactId</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span><span class="mf">2.4</span><span class="o">.</span><span class="mi">20</span><span class="o">&lt;/</span><span class="n">version</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">dependency</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="configuration">
<h2>Configuration</h2>
<p>The <tt class="docutils literal"><span class="pre">DistributedData</span></tt> extension can be configured with the following properties:</p>
<div class="highlight-scala"><pre># Settings for the DistributedData extension
akka.cluster.distributed-data {
  # Actor name of the Replicator actor, /system/ddataReplicator
  name = ddataReplicator

  # Replicas are running on members tagged with this role.
  # All members are used if undefined or empty.
  role = ""

  # How often the Replicator should send out gossip information
  gossip-interval = 2 s

  # How often the subscribers will be notified of changes, if any
  notify-subscribers-interval = 500 ms

  # Maximum number of entries to transfer in one gossip message when synchronizing
  # the replicas. Next chunk will be transferred in next round of gossip.
  max-delta-elements = 1000
  
  # The id of the dispatcher to use for Replicator actors. If not specified
  # default dispatcher is used.
  # If specified you need to define the settings of the actual dispatcher.
  use-dispatcher = ""

  # How often the Replicator checks for pruning of data associated with
  # removed cluster nodes.
  pruning-interval = 30 s
  
  # How long time it takes (worst case) to spread the data to all other replica nodes.
  # This is used when initiating and completing the pruning process of data associated
  # with removed cluster nodes. The time measurement is stopped when any replica is 
  # unreachable, so it should be configured to worst case in a healthy cluster.
  max-pruning-dissemination = 60 s
  
  # Serialized Write and Read messages are cached when they are sent to 
  # several nodes. If no further activity they are removed from the cache
  # after this duration.
  serializer-cache-time-to-live = 10s
  
  durable {
    # List of keys that are durable. Prefix matching is supported by using * at the
    # end of a key.  
    keys = []
    
    # Fully qualified class name of the durable store actor. It must be a subclass
    # of akka.actor.Actor and handle the protocol defined in 
    # akka.cluster.ddata.DurableStore. The class must have a constructor with 
    # com.typesafe.config.Config parameter.
    store-actor-class = akka.cluster.ddata.LmdbDurableStore
    
    use-dispatcher = akka.cluster.distributed-data.durable.pinned-store
    
    pinned-store {
      executor = thread-pool-executor
      type = PinnedDispatcher
    }
    
    # Config for the LmdbDurableStore
    lmdb {
      # Directory of LMDB file. There are two options:
      # 1. A relative or absolute path to a directory that ends with 'ddata'
      #    the full name of the directory will contain name of the ActorSystem
      #    and its remote port.
      # 2. Otherwise the path is used as is, as a relative or absolute path to
      #    a directory.
      dir = "ddata"
      
      # Size in bytes of the memory mapped file.
      map-size = 100 MiB
      
      # Accumulate changes before storing improves performance with the
      # risk of losing the last writes if the JVM crashes.
      # The interval is by default set to 'off' to write each update immediately.
      # Enabling write behind by specifying a duration, e.g. 200ms, is especially 
      # efficient when performing many writes to the same key, because it is only 
      # the last value for each key that will be serialized and stored.  
      # write-behind-interval = 200 ms
      write-behind-interval = off
    }
  }
  
}
</pre>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/additional/faq.html">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.lightbend.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@lightbend.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2015 <a href="http://www.lightbend.com/">Lightbend Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Aug 10, 2017
    </p>
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>

<!-- Algolia docs search -->
<script type="text/javascript">
  var version = DOCUMENTATION_OPTIONS.VERSION;

  var lang = "scala";
  var path = window.location.pathname;
  if (path.includes("/java/") || path.includes("java.html")) lang = "java";

  console.log("Search configured for:", lang, "@", version);

  docsearch({
    apiKey: '543bad5ad786495d9ccd445ed34ed082',
    indexName: 'akka_io',
    inputSelector: '#search',
    algoliaOptions: {
      hitsPerPage: 5,
      facetFilters: '[' + '["language:' + lang + '","language:general"]' + ',"version:' + version + '"]'
    }
  });

  // set up "/" as global shortcut for focusing on search
  $(document).keypress(function (event) {
    if (event.keyCode == 47) {
      $("#q").focus();
      return false; // swallow key event, otherwise the / char would be input into the search box
    }
  });
</script>

  

  </body>
</html>